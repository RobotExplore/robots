import os
from functools import reduce

import numpy as np
from numpy.linalg import norm, solve, pinv, inv
# import tensorflow as tf

AXIS = ('X', 'Y', 'Z')
batch_size = 200

'''
class ik_net:
    def __init__(self, X, Y):
        self.xs = X
        self.ys = Y
        self.lr = 0.1
        self.gstep = tf.Variable(0, trainable=False, name='gstep')

    def infer(self):
        net = tf.layers.dense(self.xs, 32, activation=tf.nn.relu)
        net = tf.layers.dense(net, 64, activation=tf.nn.relu)
        net = tf.layers.dense(net, units=64, activation=tf.nn.relu)
        self.pred = tf.layers.dense(net, 6)

    def train(self):
        self.loss = tf.losses.mean_squared_error(self.ys, self.pred)
        self.train_op = tf.train.AdamOptimizer(self.lr).minimize(self.loss, global_step=self.gstep)

    def accurate(self):
        correct = tf.less(tf.reduce_sum(tf.square(self.ys - self.pred), axis=1), 1.0)
        self.num_correct_batch = tf.reduce_sum(tf.cast(correct, tf.float32))

    def summary(self):
        tf.summary.scalar('loss', self.loss)
        self.sum = tf.summary.merge_all()

    def build(self):
        self.infer()
        self.train()
        self.accurate()
        self.summary()

    def run_train(self, n_steps):
        with tf.Session() as sess:
            writer = tf.summary.FileWriter("./log", graph=sess.graph)
            tf.global_variables_initializer().run()
            saver = tf.train.Saver(max_to_keep=20)
            ckpt_dir = os.path.dirname("./ckpt/ik_model")
            ckpt = tf.train.get_checkpoint_state(ckpt_dir)
            if ckpt and ckpt.model_checkpoint_path:
                saver.restore(sess, ckpt.model_checkpoint_path)

            step = self.gstep.eval(sess)
            for i in range(step, n_steps):
                xs, ys = next(generate_joints())
                feed_dict = {self.xs: xs, self.ys: ys}
                _, loss_ = sess.run([self.train_op, self.loss], feed_dict=feed_dict)
                if (i + 1) % 50 == 0 or i + 1 == n_steps:
                    saver.save(sess, ckpt_dir, global_step=i)
                    sum, correct_num = sess.run([self.sum, self.num_correct_batch], feed_dict=feed_dict)
                    writer.add_summary(sum, global_step=i)
                    print(f"the {i+1}th training, loss: {loss_}, acc:{correct_num/batch_size}")

    def predict(self, X):
        with tf.Session() as sess:
            sess.run(tf.global_variables_initializer())
            saver = tf.train.Saver(max_to_keep=20)
            ckpt = tf.train.get_checkpoint_state(os.path.dirname("./ckpt/ik_model"))
            if ckpt and ckpt.model_checkpoint_path:
                saver.restore(sess, ckpt.model_checkpoint_path)
            pred = sess.run(self.pred, feed_dict={self.xs: X})
        return pred
'''


def rotate(axis, deg):
    axis = str(axis).upper()
    if axis not in AXIS:
        print(f"{axis} is unknown axis, should be one of {AXIS}")
        return
    rot_x = axis == 'X'
    rot_y = axis == 'Y'
    rot_z = axis == 'Z'
    rot_mat = np.array([[(np.cos(deg), 1)[rot_x], (0, -np.sin(deg))[rot_z], (0, np.sin(deg))[rot_y], 0],
                        [(0, np.sin(deg))[rot_z], (np.cos(deg), 1)
                         [rot_y], (0, -np.sin(deg))[rot_x], 0],
                        [(0, -np.sin(deg))[rot_y], (0, np.sin(deg))[rot_x], (np.cos(deg), 1)[rot_z], 0], [0, 0, 0, 1]],
                       dtype=np.float32)
    # get a small value when np.cos(np.pi/2)
    rot_mat = np.where(np.abs(rot_mat) < 1e-10, 0, rot_mat)
    return rot_mat


def trans(axis, dis):
    axis = str(axis).upper()
    if axis not in AXIS:
        print(f"{axis} is unknown axis, should be one of {AXIS}")
        return
    trans_mat = np.eye(4)
    trans_mat[AXIS.index(axis), 3] = dis
    return trans_mat


def fk(joints):
    """
    :param DH_pramater: [link, a, d, thea]
    :return:
    """
    thea_1, thea_2, thea_3, thea_4, thea_5, thea_6 = joints
    DH = [[thea_1, 0.3991, 0, -np.pi / 2], [thea_2, 0, 0.448, 0], [thea_3, 0, 0.042, -np.pi / 2], [thea_4, 0.451, 0, np.pi / 2],
          [thea_5, 0, 0, -np.pi / 2], [thea_6, 0.082, 0, 0]]
    T = [rotate('z', thea_i).dot(trans('z', d_i)).dot(trans('x', l_i)).dot(rotate('x', a_i)) for thea_i, d_i, l_i, a_i
         in DH]
    T60 = reduce(np.dot, T)
    return T60


def jacobian(joints):
    thea_1, thea_2, thea_3, thea_4, thea_5, thea_6 = joints
    DH = [[thea_1, 0.3991, 0, -np.pi / 2], [thea_2, 0, 0.448, 0], [thea_3, 0, 0.042, -np.pi / 2], [thea_4, 0.451, 0, np.pi / 2],
          [thea_5, 0, 0, -np.pi / 2], [thea_6, 0.082, 0, 0]]
    T_end = fk(joints)
    ja_matrix = np.zeros([6, 6])
    T_pre = np.eye(4)
    for i in range(6):
        thea_i, d_i, l_i, a_i = DH[i]
        Ti = rotate('z', thea_i).dot(trans('z', d_i)).dot(
            trans('x', l_i)).dot(rotate('x', a_i))
        T_cu = np.dot(T_pre, Ti)
        zi = T_cu[:3, 2]
        ja_matrix[:3, i] = zi
        delta_d = T_end[:3, 3] - T_cu[:3, 3]
        ja_matrix[3:, i] = np.cross(zi, delta_d)
        T_pre = T_cu
    return ja_matrix


def euler_angle(T_positon):
    angle_x = np.arctan2(T_positon[1, 0], T_positon[0, 0])
    angle_y = np.arctan2(T_positon[2, 1], T_positon[2, 2])
    angle_z = np.arctan2(-T_positon[2, 0], norm(T_positon[:2, 0]))
    return np.array([angle_x, angle_y, angle_z])


def delta_p(T_tar, joints):
    delta_x = np.zeros(6)
    T_cu = fk(joints)
    delta_x[:3] = T_tar[:3, 3] - T_cu[:3, 3]
    delta_x[3:] = euler_angle(T_tar) - euler_angle(T_cu)
    return delta_x


def ik(T_tar, q_ini):
    step = 0.5
    lam = 0.5
    q_cu = q_ini.copy()
    iteration = 0
    while True:
        delta_x = delta_p(T_tar, q_cu)
        error = norm(delta_x)
        if iteration % 10 == 0:
            print(f"iteration {iteration}, error: {error}")
        if error < 1e-4 or iteration > 1e3:
            print(f"iteration {iteration}, error: {error}")
            return q_cu
        ja = jacobian(q_cu)
        f = solve(ja.dot(ja.transpose())+lam**2*np.eye(6), delta_x)
        delta_q = np.dot(ja.transpose(), f)
        q_cu = q_cu + delta_q*step
        iteration += 1


def generate_joints():
    while True:
        xs = np.zeros([batch_size, 12])
        ys = np.zeros([batch_size, 6])
        for i in range(batch_size):
            joints = np.array([(np.random.random() - 0.5) * np.pi * 2, (np.random.random() - 0.5) * np.pi,
                               np.random.random() * np.pi / 2, (np.random.random() - 0.5) * np.pi * 2,
                               (np.random.random() - 0.5) * np.pi, (np.random.random() - 0.5) * np.pi * 2])
            pose = fk(joints)
            pose = pose.flatten()[:-4]
            xs[i] = pose
            ys[i] = joints
        yield xs, ys


if __name__ == '__main__':
    # assert (rotate('x', np.pi / 2) == np.array(
    #     [[1, 0, 0, 0], [0, 0, -1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])).all(), 'rotate wrong, x'
    # assert (rotate('Y', np.pi / 2) == np.array(
    #     [[0, 0, 1, 0], [0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 0, 1]])).all(), 'rotate wrong, y'
    # assert (rotate('z', np.pi / 2) == np.array(
    #     [[0, -1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])).all(), 'rotate wrong, z'
    # assert (trans('x', 1) == np.array([[1, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])).all(), 'trans wrong'

    """
    # 图中末端的位姿矩阵为：
    [[0, 0, 1, 533], 
    [0, 1, 0, 0], 
    [-1, 0, 0, 889.1], 
    [0, 0, 0, 1]]
    各个关节的取值为：[0, -np.pi/2, 0, 0, 0, np.pi]
    """
    joints = [0, -np.pi / 2, 0, 0, 0, np.pi]
    T_tar = fk(joints)
    T_tar += 0.001
    print(ik(T_tar, joints))

    # 打印运动学计算出来的坐标和根据图中几何计算出来的坐标是否相同包
    # print(fk(joints))

    # X = tf.placeholder(tf.float32, shape=[None, 12], name='input_pose')
    # Y = tf.placeholder(tf.float32, shape=[None, 6], name='real_joints')
    # ik_densenet = ik_net(X, Y)
    # ik_densenet.build()
    # ik_densenet.run_train(15000)
    # pose = np.array([0., 0., 1., 533., 0., 1., 0., 0., -1., 0., 0., 889.1]).reshape(1, -1)
    # pred_joints = ik_densenet.predict(pose)
    # print('true joints:', joints, "pred joints:", pred_joints)
